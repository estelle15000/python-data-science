"""
Batir le minimum de batiments tout en comblant l'intégralité de la demande
https://www.coursera.org/learn/operations-research-modeling/lecture/gAB39/3-5-facility-location-covering
"""

# Import PuLP modeler functions
from pulp import *

# SET OF INVENTORY LOCATIONS J
Locations = ["A", "B","C","D"]

# SET OF DEMANDS I
Demands = ["1", "2", "3", "4", "5"]

#  SET OF DISTANCES ij
dt = [  # Demands I
    # 1 2 3 4 5
    [4, 23, 30, 54, 4],  # A   Locations J
    [3, 1, 2, 2, 3],  # B
    [25, 30, 25, 25, 35],  # C
    [25, 30, 25, 25, 35],  # D

]

# Min value to get covered
s = 5

# THIS SHOULD BE GENERATED BY CODE - Demand I is served by location J If distance is <= 5
covered = [
    [1,0.1,0.1,0.1,1],
    [1,1,1,1,0.1],
    [1,1,1,0.1,0.1],
    [1,1,1,1,1]
]


# Creates the 'prob' variable to contain the problem data
prob = LpProblem("Set covering", LpMinimize)

# # Problem variables 
J = LpVariable.dicts("location", Locations, cat='Binary')
print("--------------------J-----------------")
print(J)
print("--------------------J-----------------")

# The distance data is made into a dictionary
distances = makeDict([Locations, Demands], covered, 0)
print("--------------------J-----------------")
print(distances)
print("--------------------J-----------------")


# The objective function 
# Minimize J, which is the number of locations
prob += lpSum(J["A"]+J["B"]+J["C"]+J["D"]) 

# The constraint
# Is it covered or not ?
for w in Locations:
    for b in Demands:    
        print(int(distances[w][b])) 
        print(J[w])
        #if(distances[w][b] < 5):
        prob += distances[w][b] * J[w]  >= 1
# for w in Locations:
#     prob += (lpSum([distances[w][b] * J[w] for b in Demands]) <= 5)

# prob += 1 * J["A"] >= 1
# prob += 0 * J["A"] >= 1
# prob += 0 * J["A"] >= 1
# prob += 0 * J["A"] >= 1
# prob += 1 * J["A"] >= 1
# prob += 1 * J["B"] >= 1
# prob += 1 * J["B"] >= 1
# prob += 1 * J["B"] >= 1
# prob += 1 * J["B"] >= 1
# prob += 1 * J["B"] >= 1





# The problem data is written to an .lp file
prob.writeLP("SetCovering.lp")

# The problem is solved using PuLP's choice of Solver
prob.solve()

# The status of the solution is printed to the screen
print("Status:", LpStatus[prob.status])

# Each of the variables is printed with it's resolved optimum value
for v in prob.variables():
    print(v.name, "=", v.varValue)

# The optimised objective function value is printed to the screen
print("Total Locations  = ", value(prob.objective))

constraints = prob.constraints

print(constraints)

for name in constraints.keys():
    value = constraints.get(name).value()
    slack = constraints.get(name).slack
    print(f'constraint {name} à la valeur de : {value} et une quantité inutilisée de: {slack}')

